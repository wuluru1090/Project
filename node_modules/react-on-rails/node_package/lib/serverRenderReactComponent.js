"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var server_1 = __importDefault(require("react-dom/server"));
var ComponentRegistry_1 = __importDefault(require("./ComponentRegistry"));
var createReactOutput_1 = __importDefault(require("./createReactOutput"));
var isServerRenderResult_1 = __importDefault(require("./isServerRenderResult"));
var buildConsoleReplay_1 = __importDefault(require("./buildConsoleReplay"));
var handleError_1 = __importDefault(require("./handleError"));
function serverRenderReactComponent(options) {
    var name = options.name, domNodeId = options.domNodeId, trace = options.trace, props = options.props, railsContext = options.railsContext;
    var htmlResult = '';
    var hasErrors = false;
    try {
        var componentObj = ComponentRegistry_1.default.get(name);
        if (componentObj.isRenderer) {
            throw new Error("Detected a renderer while server rendering component '" + name + "'. See https://github.com/shakacode/react_on_rails#renderer-functions");
        }
        var reactElementOrRouterResult = createReactOutput_1.default({
            componentObj: componentObj,
            domNodeId: domNodeId,
            trace: trace,
            props: props,
            railsContext: railsContext,
        });
        if (isServerRenderResult_1.default(reactElementOrRouterResult)) {
            // We let the client side handle any redirect
            // Set hasErrors in case we want to throw a Rails exception
            hasErrors = !!reactElementOrRouterResult.routeError;
            if (hasErrors) {
                console.error("React Router ERROR: " + JSON.stringify(reactElementOrRouterResult.routeError));
            }
            if (reactElementOrRouterResult.redirectLocation) {
                if (trace) {
                    var redirectLocation = reactElementOrRouterResult.redirectLocation;
                    var redirectPath = redirectLocation.pathname + redirectLocation.search;
                    console.log("ROUTER REDIRECT: " + name + " to dom node with id: " + domNodeId + ", redirect to " + redirectPath);
                }
                // For redirects on server rendering, we can't stop Rails from returning the same result.
                // Possibly, someday, we could have the rails server redirect.
            }
            else {
                htmlResult = reactElementOrRouterResult.renderedHtml;
            }
        }
        else {
            try {
                htmlResult = server_1.default.renderToString(reactElementOrRouterResult);
            }
            catch (error) {
                console.error("Invalid call to renderToString. Possibly you have a renderFunction, a function that already\ncalls renderToString, that takes one parameter. You need to add an extra unused\nparameter to identify this function as a renderFunction and not a simple React \nFunction Component.");
                throw error;
            }
        }
    }
    catch (e) {
        hasErrors = true;
        htmlResult = handleError_1.default({
            e: e,
            name: name,
            serverSide: true,
        });
    }
    var consoleReplayScript = buildConsoleReplay_1.default();
    return JSON.stringify({
        html: htmlResult,
        consoleReplayScript: consoleReplayScript,
        hasErrors: hasErrors,
    });
}
exports.default = serverRenderReactComponent;
